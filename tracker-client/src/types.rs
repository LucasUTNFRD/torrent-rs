use std::net::SocketAddr;

use bittorrent_common::types::{InfoHash, PeerID};

#[derive(Debug)]
pub struct TrackerResponse {
    /// A list of peer addresses (IP and port) obtained from the tracker.
    /// These are potential peers for the client to connect to for downloading/uploading data.
    pub peers: Vec<SocketAddr>,
    /// The recommended interval (in seconds) that the client should wait
    /// before sending its next regular announce request to the tracker.
    pub interval: i32,
    /// The number of "leechers" (incomplete peers) currently in the swarm for this torrent.
    pub leechers: i32,
    /// The number of "seeders" (complete peers) currently in the swarm for this torrent.
    pub seeders: i32,
}

#[derive(Debug, Clone)]
pub struct AnnounceParams {
    /// The 20-byte SHA1 hash of the torrent's `info` dictionary.
    /// This uniquely identifies the torrent to the tracker.
    pub info_hash: InfoHash,
    /// A 20-byte string generated by the client at startup, used as a unique identifier.
    /// It helps the tracker differentiate between different clients.
    pub peer_id: PeerID,
    /// The port number on which the client is listening for incoming peer connections.
    pub port: u16,
    /// The total amount of data (in bytes) uploaded by the client since it started
    /// the session (i.e., since the 'started' event was sent to the tracker).
    pub uploaded: i64,
    /// The total amount of data (in bytes) downloaded by the client since it started
    /// the session (i.e., since the 'started' event was sent to the tracker).
    pub downloaded: i64,
    /// The number of bytes the client still needs to download to complete the torrent.
    pub left: i64,
    /// The type of event that triggered this announce request (e.g., started, completed, stopped).
    /// If not specified, it's a regular periodic announcement.
    pub event: Events,
}

#[derive(Debug)]
pub enum Actions {
    Connect,
    Announce,
    Scrape,
    Error,
}

impl From<&Actions> for i32 {
    fn from(action: &Actions) -> Self {
        match action {
            Actions::Connect => 0,
            Actions::Announce => 1,
            Actions::Scrape => 2,
            Actions::Error => 3,
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub enum Events {
    None,
    Completed,
    Started,
    Stopped,
}

impl From<&Events> for i32 {
    fn from(events: &Events) -> Self {
        match events {
            Events::None => 0,
            Events::Completed => 1,
            Events::Started => 2,
            Events::Stopped => 3,
        }
    }
}

impl Events {
    pub fn to_string(self) -> Option<String> {
        match self {
            Events::None => None,
            Events::Started => Some("started".to_string()),
            Events::Stopped => Some("stopped".to_string()),
            Events::Completed => Some("completed".to_string()),
        }
    }
}
